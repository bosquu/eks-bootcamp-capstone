"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertEC2NodeGroup = exports.MngClusterProvider = void 0;
const generic_cluster_provider_1 = require("./generic-cluster-provider");
/**
 * MngClusterProvider provisions an EKS cluster with a managed node group for managed capacity.
 */
class MngClusterProvider extends generic_cluster_provider_1.GenericClusterProvider {
    constructor(props) {
        var _a, _b;
        super({ ...generic_cluster_provider_1.defaultOptions, ...props, ...{
                managedNodeGroups: [{
                        ...props,
                        id: (_b = (_a = props === null || props === void 0 ? void 0 : props.id) !== null && _a !== void 0 ? _a : props === null || props === void 0 ? void 0 : props.clusterName) !== null && _b !== void 0 ? _b : "eks-blueprints-mng",
                    }]
            } });
    }
}
exports.MngClusterProvider = MngClusterProvider;
/**
 * Validates that cluster is backed by EC2 either through a managed node group or through a self-managed autoscaling group.
 * @param clusterInfo
 * @param source Used for error message to identify the source of the check
 * @returns
 */
//TODO: move to clusterInfo
function assertEC2NodeGroup(clusterInfo, source) {
    if (clusterInfo.nodeGroups != undefined && clusterInfo.nodeGroups.length > 0) {
        return clusterInfo.nodeGroups;
    }
    if (clusterInfo.autoscalingGroups != undefined && clusterInfo.autoscalingGroups.length > 0) {
        return clusterInfo.autoscalingGroups;
    }
    throw new Error(`${source} is supported with EKS EC2 only`);
}
exports.assertEC2NodeGroup = assertEC2NodeGroup;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW5nLWNsdXN0ZXItcHJvdmlkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9saWIvY2x1c3Rlci1wcm92aWRlcnMvbW5nLWNsdXN0ZXItcHJvdmlkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBR0EseUVBQW9GO0FBNkJwRjs7R0FFRztBQUNILE1BQWEsa0JBQW1CLFNBQVEsaURBQXNCO0lBRTFELFlBQVksS0FBK0I7O1FBQ3ZDLEtBQUssQ0FBQyxFQUFDLEdBQUcseUNBQWMsRUFBRSxHQUFHLEtBQUssRUFBRSxHQUFHO2dCQUNuQyxpQkFBaUIsRUFBRSxDQUFDO3dCQUNoQixHQUFHLEtBQXFDO3dCQUN4QyxFQUFFLEVBQUUsTUFBQSxNQUFBLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxFQUFFLG1DQUFJLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxXQUFXLG1DQUFJLG9CQUFvQjtxQkFDOUQsQ0FBQzthQUNMLEVBQUMsQ0FBQyxDQUFDO0lBQ1IsQ0FBQztDQUNKO0FBVkQsZ0RBVUM7QUFFRDs7Ozs7R0FLRztBQUNILDJCQUEyQjtBQUMzQixTQUFnQixrQkFBa0IsQ0FBQyxXQUF3QixFQUFFLE1BQWM7SUFDdkUsSUFBRyxXQUFXLENBQUMsVUFBVSxJQUFJLFNBQVMsSUFBSSxXQUFXLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDekUsT0FBTyxXQUFXLENBQUMsVUFBVSxDQUFDO0tBQ2pDO0lBQ0QsSUFBRyxXQUFXLENBQUMsaUJBQWlCLElBQUksU0FBUyxJQUFJLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3ZGLE9BQU8sV0FBVyxDQUFDLGlCQUFpQixDQUFDO0tBQ3hDO0lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLE1BQU0saUNBQWlDLENBQUMsQ0FBQztBQUNoRSxDQUFDO0FBUkQsZ0RBUUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhd3NfYXV0b3NjYWxpbmcgYXMgYXNnLCBhd3NfZWtzIGFzIGVrcyB9IGZyb20gXCJhd3MtY2RrLWxpYlwiO1xuLy8gQ2x1c3RlclxuaW1wb3J0IHsgQ2x1c3RlckluZm8gfSBmcm9tIFwiLi5cIjtcbmltcG9ydCB7IGRlZmF1bHRPcHRpb25zLCBHZW5lcmljQ2x1c3RlclByb3ZpZGVyIH0gZnJvbSBcIi4vZ2VuZXJpYy1jbHVzdGVyLXByb3ZpZGVyXCI7XG4vLyBDb25zdGFudHMgXG5pbXBvcnQgeyBNYW5hZ2VkTm9kZUdyb3VwIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGNsdXN0ZXIgcHJvdmlkZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW5nQ2x1c3RlclByb3ZpZGVyUHJvcHMgZXh0ZW5kcyBla3MuQ29tbW9uQ2x1c3Rlck9wdGlvbnMsIE9taXQ8TWFuYWdlZE5vZGVHcm91cCwgXCJpZFwiPiB7XG4gICAgLyoqXG4gICAgKiBUaGUgbmFtZSBmb3IgdGhlIGNsdXN0ZXIuXG4gICAgKiBAZGVwcmVjYXRlZCB1c2UgI2NsdXN0ZXJOYW1lXG4gICAgKi9cbiAgICBuYW1lPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSW4gdGhpcyBjYXNlIGlkIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0cCB0aGUgY2x1c3RlciBuYW1lXG4gICAgICovXG4gICAgaWQ/OiBzdHJpbmcsXG5cbiAgICAvKipcbiAgICAgKiBJcyBpdCBhIHByaXZhdGUgb25seSBFS1MgQ2x1c3Rlcj9cbiAgICAgKiBEZWZhdWx0cyB0byBwcml2YXRlX2FuZF9wdWJsaWMgY2x1c3Rlciwgc2V0IHRvIHRydWUgZm9yIHByaXZhdGUgY2x1c3RlclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgcHJpdmF0ZUNsdXN0ZXI/OiBib29sZWFuO1xuXG59XG5cbi8qKlxuICogTW5nQ2x1c3RlclByb3ZpZGVyIHByb3Zpc2lvbnMgYW4gRUtTIGNsdXN0ZXIgd2l0aCBhIG1hbmFnZWQgbm9kZSBncm91cCBmb3IgbWFuYWdlZCBjYXBhY2l0eS5cbiAqL1xuZXhwb3J0IGNsYXNzIE1uZ0NsdXN0ZXJQcm92aWRlciBleHRlbmRzIEdlbmVyaWNDbHVzdGVyUHJvdmlkZXIge1xuXG4gICAgY29uc3RydWN0b3IocHJvcHM/OiBNbmdDbHVzdGVyUHJvdmlkZXJQcm9wcykge1xuICAgICAgICBzdXBlcih7Li4uZGVmYXVsdE9wdGlvbnMsIC4uLnByb3BzLCAuLi57XG4gICAgICAgICAgICBtYW5hZ2VkTm9kZUdyb3VwczogW3tcbiAgICAgICAgICAgICAgICAuLi5wcm9wcyBhcyBPbWl0PE1hbmFnZWROb2RlR3JvdXAsIFwiaWRcIj4sXG4gICAgICAgICAgICAgICAgaWQ6IHByb3BzPy5pZCA/PyBwcm9wcz8uY2x1c3Rlck5hbWUgPz8gXCJla3MtYmx1ZXByaW50cy1tbmdcIixcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH19KTtcbiAgICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgY2x1c3RlciBpcyBiYWNrZWQgYnkgRUMyIGVpdGhlciB0aHJvdWdoIGEgbWFuYWdlZCBub2RlIGdyb3VwIG9yIHRocm91Z2ggYSBzZWxmLW1hbmFnZWQgYXV0b3NjYWxpbmcgZ3JvdXAuXG4gKiBAcGFyYW0gY2x1c3RlckluZm8gXG4gKiBAcGFyYW0gc291cmNlIFVzZWQgZm9yIGVycm9yIG1lc3NhZ2UgdG8gaWRlbnRpZnkgdGhlIHNvdXJjZSBvZiB0aGUgY2hlY2tcbiAqIEByZXR1cm5zIFxuICovXG4vL1RPRE86IG1vdmUgdG8gY2x1c3RlckluZm9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFQzJOb2RlR3JvdXAoY2x1c3RlckluZm86IENsdXN0ZXJJbmZvLCBzb3VyY2U6IHN0cmluZyk6IGVrcy5Ob2RlZ3JvdXBbXSB8IGFzZy5BdXRvU2NhbGluZ0dyb3VwW10ge1xuICAgIGlmKGNsdXN0ZXJJbmZvLm5vZGVHcm91cHMgIT0gdW5kZWZpbmVkICYmIGNsdXN0ZXJJbmZvLm5vZGVHcm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gY2x1c3RlckluZm8ubm9kZUdyb3VwcztcbiAgICB9XG4gICAgaWYoY2x1c3RlckluZm8uYXV0b3NjYWxpbmdHcm91cHMgIT0gdW5kZWZpbmVkICYmIGNsdXN0ZXJJbmZvLmF1dG9zY2FsaW5nR3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJJbmZvLmF1dG9zY2FsaW5nR3JvdXBzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c291cmNlfSBpcyBzdXBwb3J0ZWQgd2l0aCBFS1MgRUMyIG9ubHlgKTtcbn0iXX0=